---
title: "Programming for Data Science"
author: "yuchihchia"
date: "4/01/2020"
output: 
  html_document:
    toc: true
    toc_depth: 3
    toc_float:
      collapsed: false
      smooth_scroll: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#第3章 R Basics  
## 3.1 Package  
安裝package  
```{r}
#install.packages(c("dplyr", "lubridate", "googlesheets4"))
```
啟動package  
```{r}
library(googlesheets4)
library(dplyr)
library(lubridate)
```
***  
## 3.2 Create objects  
```{r}
a <- 2
a = 2 # = 與 <-同義
3 -> b
```
變數命名規則:  

1. 須由字母、數字、點(.)以及底線(_)構成  
2. **開頭必須是字母或是點(但點後不能接數字)**  

辨別變數命名規則  
```{r}
my_108_total_credits <- 15
#_108_total_credits <- 15
#108_total_credits <- 15
#_my_108_total_credits <- 15
my.108.total_credits <- 15
#.108.total_credits <- 15 
.my.108.total_credits <- 15
我的108學年總學分數 <- 15

#針對特殊名稱(不符變數命名規則)的處理: 在名稱前後加上` (並不是名稱的一部份)`
`我的108學年總學分數` <- 15 
`.108.total_credits` <- 15
```
常見命名方式:  

1. snake: `my_total_credits <- 15`  
2. **camel**: `myTotalCredits <- 15` (推薦使用)  

***  
##3.3 Calling an object  
```{r}
`我的年紀` <- 20
my_age <- `我的年紀`
```
要呼叫某物件時，請先確認Environment裡有該物件存在，或執行**ls()**  
```{r}
ls() #查看Environment裡共有哪些物件存在
```
***  
##3.4 Atomic vector  
```{r}
num1 <- 5
vNum1 <- c(2,5)
vNum2 <- c(2, num1)
```
只有一個值的向量可以不寫`c()`，以下兩變數值相同:  
```{r}
num1 <- 5
num2 <- c(5)
```
向量的堆疊依然是向量:  
```{r}
vNum1 <- c(-1,5)
vNum2 <- c(2,3)
vNum3 <- c(vNum1,vNum2)
vNum4 <- c(-1,5,2,3)
vNum5 <- c(c(-1,5),c(2,3))
```
vNum3、vNum4、vNum5變數值相同  
```{r}
vNum1 <- c(-1,5)
vNum2 <- c(2,3)
vNum4 <- c() # 空向量
```
```{r}
vNum3 <- c(vNum2, vNum1)
vNum4 <- c(vNum4, vNum1) # 向量疊代（recursive vector concatenate）
```
Atomic vector依其值的型態（type）而分成以下三類型:  

1. Numeric(數值，非整數) / Integer(整數)  
2. Character  
3. Logical  

### 3.4.1 Numeric / Integer  
```{r}
num1<-5 # 非整數，5會被電腦記成5.0000
num2<-5L # 整數，5L才會被電腦記成整數5
num1Vector<-c(5,6,7)
num2Vector<-c(5L,6L,7L)
```

### 3.4.2 Character  
在定義object value時，必須要用「成對」的雙引號`"`或單引號`'`，把每個字串括起來  
```{r}
char1<-"你好"
char2<-'你好'
char1Vector<-c("你好","How are you?")
```
使用`class(物件名稱)`查詢上述物件類別  
```{r}
dialogue <- c('小明說："明天不用上課。"', '小花說："真的嗎？"')
#電腦會記錄成"小明說：\"明天不用上課。\"" "小花說：\"真的嗎？\""
cat(dialogue, sep="\n")  #\n"是指換行
```
R的換行原則是: 只要指令定義不全，如括號不成對少右半邊（只有`(`卻沒看到`)`）或結尾是`,` 等等都表示指令不完整，R會再往下一行看，如下一行還是不完整就再往下一行。  
```{r eval=FALSE}
library(httr)
library(dplyr)
library(magrittr)
GET("https://api.github.com/repos/tpemartin/108-2-56-inclass-practice/commits") %>%
  content() %>%
  View()
```
查詢函數用法:  

1. Script window: 游標放在函數名稱任何一個位置，按F1。  
2. Console window: ?函數名稱 按enter。  
3. 右下角Help tab的放大鏡打函數名稱。  
```{r}
#請把以上對白改成:
#小明說：'明天不用上課。'
#小花說：'真的嗎？'
cat(c("小明說：'明天不用上課。'", "小花說：'真的嗎？'"), sep="\n")  
```
```{r eval=FALSE}
#以下程式碼中變數出席狀況表單網址缺乏變數值，請貼上本班出席表單網址使該變數值有定義。
library(googlesheets4)
library(httpuv)
`出席狀況表單網址` <-  "https://docs.google.com/spreadsheets/d/1EAG49qDKPWWi0ebkVr29TLrvVnoBPfkvxYY-J3xLAHY/edit#gid=458686645"
ss <- as_sheets_id(`出席狀況表單網址`)
homework_sheet <- sheets_read(ss, sheet=1)
```
### 3.4.3 Logical  
邏輯：  

* 為「真」: `T`或`TRUE` (要全大寫)。  
* 為「否」: `F`或`FALSE` (要全大寫)。  
```{r}
logi1 <- c(T,TRUE,F,FALSE,FALSE)
```
邏輯值遇到數學運算時T會被當成1，而F會被當成0
```{r}
#sum(數值向量): 加總向量內所有元素的數值。
sum(logi1)
```
### 3.4.4 `typeof()`  
顯示atomic vector元素的基本認定型態，它代表電腦記憶體在儲存時真正看待的型態。  
```{r}
num <- c(1.5, 2, 3)
int <- c(1L, 3L, -2L)
char <- c("1.5","2","3")
logi <- c(T,T,F)
typeof(num)
typeof(int)
typeof(char)
typeof(logi)
```
### 3.4.5 `class()`
依資料的螢幕顯示型態及能對它進行的操作所做的分類。  
```{r}
class(num)
class(int)
class(char)
class(logi)
```
## 3.5 Atomic Vector Extended  
以下介紹兩個數字串向量而延伸的兩個類別:  

* factor: 類別資料[`factor(字串向量)`]  
* POSIXct/POSIXt: 時間資料[`ymd_hms(字串向量)`]  

### 3.5.1 Factor  
```{r}
#10位學生的主修科系
majors10_char <- c('經濟學系','社會學系','社會學系','經濟學系','經濟學系','社會學系','經濟學系','經濟學系','經濟學系','社會學系')
typeof(majors10_char)
class(majors10_char)
majors10_factor <- factor(majors10_char)
# 或
majors10_factor <- factor(c('經濟學系','社會學系','社會學系','經濟學系','經濟學系','社會學系','經濟學系','經濟學系','經濟學系','社會學系')
)
typeof(majors10_factor)
class(majors10_factor)
```
majors10_char及majors10_factor的螢幕顯示型態是不同的:  
```{r}
majors10_char
majors10_factor
```
`as.integer()`將資料的class轉成integer。由於factor被轉成integer後，其螢幕顯示會顯示電腦是用什麼數字在存這些類別資料。  
```{r}
as.integer(majors10_factor) 
```
數字與類別文字的對照表mapping table:  
```{r}
levels(majors10_factor)
```
Factor屬於atomic vector延伸的類別，其基本儲存型態還是會落在先前的基本型態裡，但多了資料顯示的mapping table。  

### 3.5.2 Class conversion  
R有一系列的`as.{class名稱}(物件)`的函數用來轉換物件的class；`as.{type名稱}(物件)`用來轉換物件的type。  
例如: `as.integer(物件)`會將該物件(嘗試)轉成integer class/type的物件。  
```{r}
stringInteger <- c("1","2","-11")
class(stringInteger) # 無法進行數值運算
```
```{r error=TRUE}
stringInteger+2
```
```{r}
trueInteger <- as.integer(stringInteger)
class(trueInteger) # 可以進行數值運算
typeof(trueInteger)
trueInteger+2
char3 <- c("小明","1","3")
as.integer(char3) #因為"小明"無法轉換為numeric形式，故硬是轉換下會變成NA
```
R的函數均不會主動更改輸入物件，只會把結果值另行輸出，所以若要保留轉換結果則必需指定到一個物件名稱上。
```{r}
stringInteger <- as.integer(stringInteger)
class(stringInteger)
```
```{r}
#以下為學生學號
studentId <- c(410773002, 410773015)
#它目前是什麼class
class(studentId)
#學號用什麼class比較合理
studentId <- as.character(studentId)
class(studentId)
```
### 3.5.3 Date / Time
處理時間所需資訊:  

* 時間輸入方式  
* 時間來自時區  
* 時間儲存以哪個時區為準（進行比較用）  
其中最後一點通訊協定是採UTC時區為公定標準，故不用煩惱。  
```{r}
library(lubridate)
```
#### 3.5.3.1 台北  
**2020-03-18 13:52:40**  

* 時間輸入方式: ymd_hms  
* 時間來自時區: Asia/Taipei  
```{r}
tpeTime <- ymd_hms("2020-03-18 13:52:40", tz="Asia/Taipei")
```
我們使用lubridate中的ymd_hms函數有以下兩種做法：  

1. 作法一: 使用library()
```{r}
library(lubridate)
tpeTime <- ymd_hms("2020-03-18 13:52:40", tz="Asia/Taipei")
```
2. 作法二: 不使用library()
```{r}
tpeTime <- lubridate::ymd_hms("2020-03-18 13:52:40", tz="Asia/Taipei")
```
#### 3.5.3.2 葡萄牙
**Mar.18, 2020, 05:52:40**  

* 時間輸入方式: mdy_hms  
* 時間來自時區: Europe/Lisbon  
```{r}
pgTime <- mdy_hms("Mar.18, 2020, 05:52:40", tz="Europe/Lisbon")
```
來自相同時區、相同輸入方式的時間文字字串，可以直接套入相同函數轉成Date/Time類別。
```{r}
tpeTime <- c("2020-03-18 13:52:40", "2020-03-11 03:12:40")
tpeTime <-ymd_hms(tpeTime, tz="Asia/Taipei")
#相當於
tpeTime <- ymd_hms(c("2020-03-18 13:52:40","2020-03-11 03:12:40"), 
                   tz="Asia/Taipei")
```
若時間字串來自UTC，那可以不設定tz參數，即
```{r}
ymd_hms(c("2020-03-18 13:52:40","2020-03-11 03:12:40"))
```
若時間字串長得像“2020-03-11T06:56:17Z”，它來自UTC時區:  
```{r}
ymd_hms("2020-03-11T06:56:17Z")
```
```{r  eval=FALSE}
browseURL("https://docs.google.com/spreadsheets/d/1EAG49qDKPWWi0ebkVr29TLrvVnoBPfkvxYY-J3xLAHY/edit#gid=458686645")
```
```{r}
studentTime <- c(ymd_hms("2020-03-04T06:56:29Z"),
                 ymd_hms("2020-03-11 14:16:43", tz="Asia/Taipei"),
                 ymd_hms("2020-03-11 14:34:33", tz="Asia/Taipei")
                 )
studentTime
```
#### 3.5.3.3 以某個時區顯示  
以UTC表示  
```{r}
with_tz(tpeTime, tzone="UTC")
with_tz(pgTime, tzone="UTC")
```
以Europe/Paris表示  
```{r}
with_tz(tpeTime, tzone="Europe/Paris")
with_tz(pgTime, tzone="Europe/Paris")
with_tz(studentTime, tzone = "Europe/Paris")
```
#### 3.5.3.4 type  
```{r}
class(tpeTime)
typeof(tpeTime)
as.numeric(tpeTime)
as.numeric(pgTime)
```
Date/Time的儲存其實是數值，它的原點是UTC時區的1970-01-01 00:00:00。 as.numeric(tpeTime)的值顯示tpeTime離那個原點已過了多少秒。
```{r}
#數於Date/Time class的向量內容是數值，所以它是可以做數值相減。請問台北“2020-03-11 12:55:30”與巴黎“2020-02-13 15:33:10”相減後會出現什麼？
ymd_hms("2020-03-11 12:55:30", tz="Asia/Taipei")-ymd_hms("2020-02-13 15:33:10", tz="Europe/Paris")
```
## 3.6 List  
特色:   

1. 每個元素值可以是不同type的物件值。
```{r}
`小明交易1` <- list(`時間`=ymd_hms("2020-03-31T13:40:55Z"),
                    `飲料店`="一芳",
                    `數量`=2,
                    `飲料`="水果茶")
str(`小明交易1`)
```
2. 物件值可以是vector形式，也可以list。  
```{r}
# list含兩個vectors
`小明108學年課表A` <- list(c("108-1","高級會計學","高等統計學"),
                           c("108-2","食在拉丁美洲")
                          )
str(`小明108學年課表A`)
# list含兩個lists
`小明108學年課表B` <- list(list("108-1","高級會計學","高等統計學"),
                           list("108-2","食在拉丁美洲")
                          )
str(`小明108學年課表B`)
# list含兩個lists, 子層list又各含兩個vectors
`小明108學年課表C` <- list(list(c("108-1"), # 可只寫 "108-1"
                                c("高級會計學","高等統計學")
                               ),
                           list(c("108-2"),
                                c("食在拉丁美洲")
                               )
                           )
str(`小明108學年課表C`)
```
3. 物件值可以取名。
```{r}
`小明108學年課表D` <- list(`108學年第1學期`=list(c("108-1"),
                                                 c("高級會計學","高等統計學")
                                                ),
                           `108學年第2學期`=list(c("108-2"),
                                                 c("食在拉丁美洲")
                                                )
                          )
str(`小明108學年課表D`)
commit <- list(author=list(name="Martin老師",
                           email="mtlin@gm.ntpu.edu.tw",
                           date=ymd_hms("2020-03-25T07:17:40Z")
                           ),
               comitter=list(name="emilyluckey",
                             email="emily007@gmail.com",
                             date=ymd_hms("2020-03-26T08:18:40Z")
                             ),
               message="update"
               )
str(commit)
```
網路上的資料回傳大部份時候長得像list的格式。

這種回傳資訊格式叫做**JSON**(JavaScript Object Notation)，每個程式語法都會準備一個物件形式用來儲存接收到的JSON資料；R會用list type，Python會用dictionary type。  

也因為每個程式都可接收JSON形式資料，不同程式開發者若有必要進行網路資訊交換時會將複雜資料結構轉成JSON再交換出去。  

我們的程式要在網路送出commit資訊時，可以透過以下程序將list轉成JSON: 
```{r}
library(jsonlite)
toJSON(commit)
```
```{r}
#學生小明，在108學年第1學期修了Alice老師所授的個體經濟學(得分85分)、Mark老師所授的總體經濟學(得分73分)。在108學年第2學期修了Jason老師所授的作業研究(得分90分)。
`小明的修課記錄` <- list(name="小明",
                         semesters=list(`108-1`=list(
                           course1_1081=list(name="個體經濟學",
                                             teacher="Alice",
                                             grade=85
                                             ),
                           course2_1081=list(name="總體經濟學",
                                             teacher="Mark",
                                             grade=78
                                             )
                                       ),
                                        `108-2`=list(
                           course1_1082=list(name="作業研究",
                                             teacher="Jason",
                                             grade=90
                                             )
                                                    )
                                       )
                        )
str(`小明的修課記錄`)
```
```{r}
#今("2020-03-31")明("2020-04-01")兩天「台北市」氣溫最高25度，最低18度；「新北市」氣溫最高24度，最低15度。
weather <- list(today=list(taipei=list(city="台北市",
                                       highest_temp=c(highest_temp=18),
                                       lowest_temp=c(lowest_temp=15)
                                       ),
                           newTaipei=list(city="新北市",
                                       highest_temp=c(highest_temp=18),
                                       lowest_temp=c(lowest_temp=15)
                                       )
                           ),
                tommorrow=list(taipei=list(city="台北市",
                                       highest_temp=c(highest_temp=18),
                                       lowest_temp=c(lowest_temp=15)
                                       ),
                           newTaipei=list(city="新北市",
                                       highest_temp=c(highest_temp=18),
                                       lowest_temp=c(lowest_temp=15)
                                       )
                           )
                )
str(weather)
```
game的定義： A game involves three components:

1. A list of players  
2. Moves each player can make (strategies)  
3. A listing of payoffs, or benefits, for each player on each eventual outcome (a utility function for outcomes)  
<img src="C:/Users/USER/Documents/GitHub/yikahui/gametheory.png" style="display:block; margin:auto; width:50%;">  
```{r}
game<-list(players=list(player1="A",player2="B"),
           strategies=list(player1=list(strategy1="stay_silent",strategy2="betray"),
                           player2=list(strategy1="stay_silent",strategy2="betray")
                           ),
           `payoffs: (player1, player2)`=list(
               #mapping from all possible player1 strategy vs player2 strategy
               player1=list(strategy1=list(player2=list(strategy1=c(-1,-1),
                                                        strategy2=c(-3,0))
                                           ),
                            strategy2=list(player2=list(strategy1=c(0,-3),
                                                        strategy2=c(-2,-1)
                                                        )
                                           )
                            )
                                            )
           )
str(game)
# 查詢strategies
game$strategies$player1$strategy1
game$strategies$player2$strategy2
# 查詢payoffs
## player1:strategy1, player2:strategy2
game$`payoffs: (player1, player2)`$player1$strategy1$player2$strategy2
## player1:strategy2, player2:strategy2
game$`payoffs: (player1, player2)`$player1$strategy2$player2$strategy2
```
## 3.7 物件儲存  

* 存下Global Environment中有的物件: `save(object1, object2, ..., file="myData.Rda")`  
* 下次取回來Global Environment用: `load("myData.Rda")`
```{r}
object1 <- c(2,5)
object2 <- ymd_hms(c("2015-03-22 12:28:42","2017-12-22 15:33:48"),
                   tz="Asia/Taipei"
                  )
object3 <- list(2, FALSE, c("a","b","c"))
save(object1, object2, object3, file="threeObjects.Rda")
```
```{r}
load("threeObjects.Rda")
```

# 第4章 Operation on vector and list  
## 4.1 選取元素  
### 4.1.1 選「一個元素」  
* 用位置選: `物件[[數字]]`  
```{r}
vectorExample <- c("小明","小英","大雄")
#確認有多少位置可選
length(vectorExample)
vectorExample[[1]]
vectorExample[[3]]
listExample <- list(student="小明",
                    `學期`=list(`108-1`=list(list(name="個體經濟學",
                                                  teacher="Alice",
                                                  grade=85)
                                             ),
                                `108-2`=list(list(name="總體經濟學",
                                                  teacher="Mark",
                                                  grade=78)
                                             )
                                )
                    )
#確認有多少位置可選
length(listExample)
listExample[[1]]
listExample[[2]]
```
* 用名字選: `物件$名字`
```{r}
#確認有多少名字可選
names(listExample)
listExample$student
listExample$`學期`
```
* 用名字選: `物件[["名字"]]`
```{r}
listExample[["student"]]
listExample$student
listExample[["學期"]]
listExample$`學期`
```
```{r}
#新北市各區衛生所之門診時間及疫苗種類彙整表
fromJSON("http://data.ntpc.gov.tw/api/v1/rest/datastore/382000000A-000157-002",
         simplifyDataFrame = F) -> newTaipeiCityVaccine
str(newTaipeiCityVaccine$result, max.level = 1) #顯示到第一層
```

### 4.1.2 選「多個元素」  

* 用位置選: `物件[數字向量]`
```{r}
vectorExample
vectorExample[c(1,3)]
vectorExample[c(3,2,1)] #產生重新排列效果
str(listExample, max.level=1)
listExample[c(1,2)]
```
* 用名字選: `物件[名字向量]`
```{r}
listExample[c("student","學期")]
```
```{r}
#臺北市夜市資料(來自臺北市食材登錄平台食材來源資訊)
fromJSON("https://www.dropbox.com/s/qnm9bnz7vccrvcz/taipeiNightMarkets.json?dl=1", simplifyDataFrame = F) -> taipeiNightMarkets
names(taipeiNightMarkets)
str(taipeiNightMarkets[c("士林觀光夜市","寧夏觀光夜市","饒河街觀光夜市")])
```
* 用邏輯向量選: `物件[邏輯向量]`
```{r}
vectorExample
vectorExample[c(T,T,F)]
str(listExample[c(T,T)])
```
```{r}
str(taipeiNightMarkets[c(T,F,F,F,T,F,F,F,F,T,F,F,F,T)])
```
**`[[.]]`與`[.]`比較**
```{r}
str(listExample)
#以下兩個表面都是選取"學期"
get1 <- listExample[["學期"]]
get2 <- listExample["學期"]
```
* `[[.]]`: 拿出某個物件值。`listExample[["學期"]]`將listExample裡的"學期"物件值拿出來
* `[.]`: 留下某個物件值。`listExample["學期"]`「只留下」listExample裡的"學期"物件值
```{r}
get1
get2
str(get1)
str(get2)
get1$`108-1`[[1]]$teacher
get2[[1]]$`108-1`[[1]]$teacher
```

### 4.1.3 連鎖選取  
```{r}
numVector <- c(2,3,6,-1,4,2,6)
numVector[c(1,4)][[1]]
numVector[c(T,T,F,T,F,F,T)][c(1,4)]
majors <- c("經濟學系","經濟學系","社會學系","社工系","經濟學系")
names <- c("小英", "小美", "大雄","阿華", "阿尼")
gender <- c("F","F","M","F","M")
econOnly <- majors=="經濟學系"
names[econOnly]
gender[econOnly]
econFemaleOnly <- gender[econOnly]=="F"
names[econOnly][econFemaleOnly]
```
#### 4.1.3.1 list應用
atomic vector其實也可以像list對元素命名，然而用名稱取元素值在atomic vector:  

* 只能用`[.]`或`[[.]]`  
* 不能用`$.` (`$.`只適用在list)  
```{r}
vector1 <- c(a=1,b=3,c=4)
```
```{r}
vector1[["a"]] #vector1$a 不能用
vector1[c("a","c")]
list1 <- list(a=1,b=3,c=4)
```
```{r}
list1[["a"]]
list1[c("a","c")]
list1$a
#今明兩日台北市、新北市氣溫
str(weather)
weather[[1]][[2]]$highest_temp # 今天/新北市/highest_temp
weather[[2]][[2]]$highest_temp # 明天/新北市/highest_temp
```
## 4.2 新增/替換/刪除元素  
### 4.2.1 新增/替換元素  
元素提取`[.]`,`[[.]]`,`$.`也可用來進行元素「值」的修改與新增, 使用方法為：  
  
* `obj[.] <- value`  
* `obj[[.]] <- value`  
* `obj$. <- value`  

若`.`所指定的元素不存在，則為「新增」。  

若`.`所指定的元素存在，則為「修改」。  
```{r}
a <- c("1","b","TRUE")
a
a[[2]] <- "c" # 元素存在: 替換
a[[4]] <- "7" # 元素不存在： 增加
a[c(5,6)] <- c("J", "K")
a
#增加一個“Johnson”使用[[.]]<-
a[[7]] <- "Johnson"
#使用前一章的向量疊代(recursive vector concatenate)法，新增一個“Mary”
a <- c(a,"Mary")
a
library(lubridate)
list1 <- list(list(name="Jack",
                   birthday=ymd("1998-03-21"),
                   status=c(height=177, weight=80)
                   )
              )
str(list1)
# 更改日期
list1[[1]]$birthday <- ymd("1997-03-21")
# 新增資料
list1[[2]] <- list(name="Mary",
                   birthday=ymd("1998-08-24")
                   )
str(list1)
#替Mary依Jack的記錄方式增加身高163，體重45
list1[[2]]$status <- c(height=163, weight=45)
#將Jack的身高改成176
list1[[1]]$status[[1]] <- 176
str(list1)
```
使用`[.] <- `  

由於`[.]`會保留母層結構，所以`<-`右側要使用和母層相同的型態設定：  

* 母層若為list，則需用`list(...)`方式增加  

* 母層若為atomic vector，則用`c(...)`方式增加  
```{r}
list1[[1]][["age"]] <- 21
list1[[2]]["age"] <- list(21)
# 改變「一個」時，使用[[ ]]比較不會錯。
str(list1)
list1[[1]][c("bloodType","registered")] <- list("AB",TRUE)
str(list1)
#由listExample進行以下任務: 
#108-1新增一個產業經濟學
str(listExample)
listExample$`學期`$`108-1`[[2]] <- list(name="產業經濟學")
#產業經濟學，同時加上教師Wen及成績88
listExample$`學期`$`108-1`[[2]][c("teacher","grade")] <- list("Wen",88)
str(listExample)
```
### 4.2.2 刪除元素  
刪除可以使用`[- c(數字位置)]`  

* 只能「一個」中括號（`[[.]]`不能接受負數值）  
* 只能用負數值，不能用元素名稱  
```{r}
a[-c(1,3)]
a[c(-2)]
print(a)
a[-c(1,3)] -> a # 要回存才算真的刪除
#自先前list1範例:刪除Jack的status., blookType.，以及Mary的status
list1[[1]][-c(3,5)] -> list1[[1]] # 小心回存的位置
list1[[2]][-3] -> list1[[2]]
str(list1)
```
list元素要刪除時也可以用`[.]<-NULL`, `[[.]]<-NULL`
```{r}
list1[[2]][c(1,2)] <- NULL
str(list1)
```
## 4.3 On numeric class  
加、減、乘、除: `+`, `-`, `*`, `/`  
餘數: `%%`  
次方: `**` 或 `^`  
```{r}
a <- c(2, 3, 5)
b <- c(4,-1, 3)
a+b
a-b
a*b
a/b
a %% b
a ** b
#奇、偶數判斷  
sequenceNums <- c(11, 6, 8, 11, 12, 11, 3, 7, 10, 8)
sequenceNums %% 2 # 餘數為1則是奇數，0則是偶數
```
在多數時候R向量間的運算都是**elementwise**(個別元素)的運算：所有向量一一取出各自對應相同位置的元素值進行運算  
```{r eval=FALSE}
# a+b 即等於
c(2+4, 3+(-1), 5+3)
# a**b 即等於
c(2**4, 3**(-1), 5**3)
```
當向量間不等長度時，R會對短的向量進行Recycle的動作(即Python的Broadcast): 將其中較短的向量反複堆疊到可以長得跟最長的向量一樣長度  
```{r eval=FALSE}
5*c(1,3,4)+7
# 對向量5，向量7進行recycle:
c(5,5,5)*c(1,3,4)+c(7,7,7)
# Recycle等長後才進行elementwise operation:
c(5*1+7, 5*3+7, 5*4+7)
```
```{r}
# 狀況一: 堆疊一定倍數剛好一樣長
c(2,3)/c(-2,-13,10,22) #等同於 c(2,3,2,3)/c(-2,-13,10,22)
# 狀況二: 倍數堆疊一定會超過，只好截斷
c(2,3)/c(-2,-13,10) #等同於 c(2,3,2)/c(-2,-13,10)
```
Recycling不只用在數值class，只要向量間的處理要等長度才合理時，recycling通常也會用在其他的class  
```{r}
paste0(c("我叫"), c("小明","小美")) #等同於 paste0(c("我叫","我叫"), c("小明","小美"))
```
## 4.4 Relational Operators  
```{r}
example <- list(
  name=c("小明","小花","小新","美美"),
  height=c(175,166,170,160),
  weight=c(77,NA,60,43),
  birthday=lubridate::ymd(c("1998-03-11","1999-12-22","1995-08-22","2001-10-10")),
  hobby=c("美食 旅遊","旅遊 時尚","3C 美食","音樂 旅遊"),
  residence=c("Taipei","New Taipei","Taichung","Kaohsiung"),
  allowance=factor(c("0-1000","1001-2000","2000+","1001-2000")),
  bloodType=c("A","B","B","O")
)
```
### 4.4.1 比較  
`>`，`<`，`<=`，`>=`: 分別為大於、小於、小於等於、大於等於  

比較關係可套用在下列狀況:  

* 數字比較  
* 時間比較  
* 可排序類別資料比較 (需先將類別資料的類別排序)  

1. 數字比較  

example裡誰的身高大於等於170  
```{r}
print(example[c("name","height")])
pick_above170 <- example$height >= 170
example$name[pick_above170]
```
不同屆入學學生在2年級的學業表現  
```{r}
#匯入transcript100to103的資料
source("https://www.dropbox.com/s/qsrw069n94k61lj/transcript100to103_list.R?dl=1") 
# 只要成績大於85的
pick_above85 <- transcript100to103$`成績` > 85
# 各學屆2年級人數
table(transcript100to103$`學屆`) #table適用於類別資料或間斷資料，顯示各個類別的重複次數
# 各學屆2年級成績大於85人數
table(transcript100to103$`學屆`[pick_above85])
```
2. 時間比較:  

example裡誰1998年(含)以後出生  
```{r}
print(example[c("name","birthday")])
pick_after98 <- example$birthday >= lubridate::ymd("1998-01-01")
example$name[pick_after98]
```
美元匯率: 選出1998年1月(含)以後的匯率
```{r}
#匯入exchangeRate的資料
source("https://www.dropbox.com/s/16h6ggua6qtydci/exchangeRate.R?dl=1")
# 只要1998年1月（含）以後的
library(lubridate)
pick_after98_01 <- exchangeRate$`期間` >= ymd("1998-01-01")
exchangeRate_after98 <- list(`期間`=exchangeRate$`期間`[pick_after98_01],
                             `幣別`=exchangeRate$`幣別`[pick_after98_01],
                             `匯率`=exchangeRate$`匯率`[pick_after98_01])
```
3. 可排序類別資料比較:  

factor資料可進一步分成可排序與不可排序的，如:  

* 可排序: 以年齡層區分的類別，以所得級距區分的類別等  
* 不排序: 性別，學系等  

factor的設定在不調整時內定為不可排序資料，如要改成可排序類別資料，以先前已處理好的example$allowance為例:  
```{r}
example$allowance <- ordered(example$allowance)
```
或在設定為factor時即把levels排好，並`ordered=T`:
```{r}
example$allowance <- factor(example$allowance,
                            levels=c("0-1000", "1001-2000", "2000+"),
                            ordered = T # 設定為可排序factor
                            )
```
example裡誰零用錢大於1000  
```{r}
print(example[c("name","allowance")])
pick_allowanceOver1000 <- example$allowance >= "1001-2000"
example$name[pick_allowanceOver1000]
```
刑事案件被害者人數
```{r}
jsonlite::fromJSON("https://www.dropbox.com/s/3uijub7xheib405/list_victimAges_female.json?dl=1", simplifyDataFrame = F) -> list_victimAges_female
str(list_victimAges_female)
list_victimAges_female$`數目` <- as.integer(list_victimAges_female$`數目`)
list_victimAges_female$`年齡層` <- as.factor(list_victimAges_female$`年齡層`)
```
```{r}
levels(list_victimAges_female$`年齡層`) -> levels_ages
print(levels_ages)
#將levels順序改成: 不詳、總計、0_5歲、12_17歲、...、70歲以上
levels_new <- c(levels_ages[c(12,13,1,8,2:7,9:11)])
str(list_victimAges_female$`年齡層`)
levels(list_victimAges_female$`年齡層`) <- levels_new
list_victimAges_female$`年齡層` <- ordered(list_victimAges_female$`年齡層`)
```
「30_39歲以上受害者」的數目
```{r}
pick_above30 <- list_victimAges_female$`年齡層` >= "30_39歲"
sum(list_victimAges_female$`數目`[pick_above30], 
    na.rm = T #將數目中資料為NA的排除再加總，若數值資料中有NA將無法加總運算
    )
```
### 4.4.2 相等、屬於  
`==`: 等於  
`!=`: 不等於  
[`==`與`!=`可使用於字串]  
`%in%`: 屬於(左邊元素「一一」檢視是不是屬於右邊元素集合)  

example裡誰血型B型  
```{r}
print(example[c("name","bloodType")])
pick_bloodB <- example$bloodType == "B"
example$name[pick_bloodB]
#創造可留下偶數的「要/不要」向量pick_evens
sequenceNums <- c(11, 6, 8, 11, 12, 11, 3, 7, 10, 8)
pick_evens <- (sequenceNums%%2) == 0
sequenceNums[pick_evens]
x <- c(1,5,8)
y <- c(5,8)
# x裡的元素值是不是屬於y集合
x %in% y
```
example裡誰來自大台北地區  
```{r}
print(example[c("name","residence")])
set_TaipeiMetro <- c("Taipei","New Taipei")
pick_fromTaipeiMetro <- example$residence %in% set_TaipeiMetro
example$name[pick_fromTaipeiMetro]
```
創造可選出來自法商學院的「要/不要」向量，pick_lawBusiness  
```{r}
str(transcript100to103)
unique(transcript100to103$`學院`) #unique適用於類別資料或間斷資料，顯示共有哪些類別
pick_lawBusiness <- transcript100to103$`學院` %in% c("法學院","商學院")
```
### 4.4.3 Negation (否定用法)  
在「要/不要」向量前加上`!`會成為否定句的「要/不要」向量，元素裡的TRUE會轉成FALSE，FALSE則轉成TRUE  
```{r}
pick_not_fromTaipeiMetro <- !pick_fromTaipeiMetro
# 或
pick_not_fromTaipeiMetro <- !(example$residence %in% set_TaipeiMetro) 
```
```{r}
example$name[pick_not_fromTaipeiMetro]
# 或
example$name[!pick_fromTaipeiMetro]
```
### 4.4.4 資料狀態  
* `is.na`: 有缺失  
[會告訴你各個元素是不是NA]  
* `is.{class/type name}`: 例如`is.integer`, `is.character`, `is.factor`, ...等  
[會告訴你這筆資料是不是...型態]  

有時資料有缺失，在R裡會記成NA(即not available)如下例: 
```{r}
x2 <- c(1,NA,10)
y2 <- c(-1,NA,20)
x3 <- c(NA,"小花")
y3 <- c(NA,"小華")
is.na(x2)
is.numeric(y2)
is.character(x3)
```
example裡誰沒有體重資料
```{r}
print(example[c("name","weight")])
pick_na <- is.na(example$weight)
example$name[pick_na]
```
R還有一種特別的缺失資料NaN (即not a number)，出現在沒有定義的數學運算上，如:
```{r}
0/0
```
創立可選出缺失資料的「要/不要」向量pick_na, 並計算有多少筆缺失
```{r}
list_victimAges_female$`數目` <- as.integer(list_victimAges_female$`數目`)
pick_na <- is.na(list_victimAges_female$`數目`)
total_na <- sum(pick_na)
print(total_na)
```
### 4.4.5 字元偵測  
`stringr::str_detect()`  

example裡誰喜歡美食  
```{r}
print(example[c("name","hobby")])
pick_loveFood <- stringr::str_detect(example$hobby,"美食")
example$name[pick_loveFood]
```
新北市垃圾車路線
```{r}
jsonlite::fromJSON("https://data.ntpc.gov.tw/od/data/api/EDC3AD26-8AE7-4916-A00B-BC6048D19BF8?$format=json") -> garbageRoutes
# typeof(): 查詢電腦實質上如何看待garbageRoutes
typeof(garbageRoutes)  
# class(): 查詢電腦把它能進行的操作運算歸屬於哪一類型
class(garbageRoutes) #代表garbageRoutes這筆資料除了能使用list所有操作手法外，還可以用data.frame的操作
# 由linename元素判斷垃圾車有幾條路線。
factor(garbageRoutes$linename) -> garbageRoutes$linename
levels(garbageRoutes$linename)
# 由linename創造： 可篩選出下午路線的「要/不要」向量pick_afternoonRoutes。
pick_afternoonRoutes <- stringr::str_detect(garbageRoutes$linename,"下午")
garbageRoutes_afternoon <- unique(garbageRoutes$linename[pick_afternoonRoutes])
```
#### 4.4.5.1 閱讀函數說明  
```{r eval=FALSE}
?str_detect
```
* Title  
Detect the presence or absence of a pattern in a string.

* Description  
Vectorised over string and pattern. Equivalent to `grep(pattern, x)`. See `str_which()` for an equivalent to `grep(pattern, x)`.

* Usage
`str_detect(string, pattern, negate = FALSE)`
* Arguments  
    + string:  
    input character vector. Either a character vector, or something coercible to one.
  
    + pattern:  
    Pattern to look for. The default interpretation is a regular expression, as described in stringi::stringi-search-regex. Control options with regex(). Match a fixed string (i.e. by comparing only bytes), using fixed(). This is fast, but approximate. Generally, for matching human text, you’ll want coll() which respects character matching rules for the specified locale. Match character, word, line and sentence boundaries with boundary(). An empty pattern, "“, is equivalent to boundary(”character").
  
    + negate:  
    If TRUE, return non-matching elements.

* Value  
A logical vector.

* Examples  
```{r}
library(stringr)
fruit <- c("apple", "banana", "pear", "pinapple")
str_detect(fruit, "a")
str_detect(fruit, "^a") #字首為a開頭
str_detect(fruit, "a$") #字尾為a結尾
str_detect(fruit, "b")
str_detect(fruit, "[aeiou]") #有出現a,e,i,o,或u
```
疾病管制署傳染病答問集: 找出問題中包含"肺炎"字眼的問題
```{r}
CDC_chatbox <- readr::read_csv("http://od.cdc.gov.tw/pr/CDC_chatbox.csv")
pick_pneumonia <- stringr::str_detect(CDC_chatbox$Question,"肺炎")
CDC_chatbox$Question[pick_pneumonia]
```
## 4.5 On logical class  
邏輯向量間(即「要/不要」向量)的操作主要是以下幾個:  

* `&`: and  
* `|`: or  
```{r}
str(example)
pick_above170 <- example$height >= 170
pick_bloodB <- example$bloodType == "B"
pick_loveFood <- stringr::str_detect(example$hobby,"美食")
pick_na <- is.na(example$weight)
pick_after98 <- example$birthday >= lubridate::ymd("1998-01-01")
set_TaipeiMetro <- c("Taipei","New Taipei")
pick_fromTaipeiMetro <- example$residence %in% set_TaipeiMetro
```
誰"喜歡美食"且"血型為B型"
```{r}
str(example[c("name","hobby","bloodType")])
example$name[pick_loveFood & pick_bloodB]
```
誰"1998以後(含)出生"或"不住大台北"
```{r}
example[c("name","birthday","residence")]
example$name[pick_after98 | !pick_fromTaipeiMetro]
```
誰1998以後（含）出生且住大台北且血型B型
```{r}
example$name[pick_after98 & pick_fromTaipeiMetro & pick_bloodB]
```
## 4.6 On character class  
這節使用stringr套件，同時也有一小部份用到glue套件  
[在「字元偵測」的小節中使用到的`str_detect()`也屬於stringr套件]  
```{r}
library(stringr)
library(glue)
```
對character vector每個元素進行部份資訊粹取:  

* 學號"410873002"，其中108是入學年，73是學系碼。對100學年以後學生學系碼是固定在「第5、6位元」
```{r}
str_sub("410873002", 5, 6)
```
* 地址幾號: "大學號151號"，只知道號碼在「號」這字前面，但它會是第幾個位元不知道  
    + 這時候就需要使用Regular Expression (regex, 正規表示式)  

* 如何讀入"民國108年12月5日"、"民國98年10月5日"？  
    + lubridate偵測年時，只有西元年的概念  
    + 要能想辦法把上面的"108","98"取出加上1911  
    + 因為lubridate裡的字串日期時間判斷採取的策略是「忽略非數字文字」只以「數字組合」(還允許各地習慣使用的文字，如March, Mar都是3月的意思)判斷時間，所以以下幾個都可以產生「西元」"2019-12-05":  
```{r eval=FALSE}
lubridate::ymd(
  c("民國2019年12月05日", 
    "馬丁2019的12課05muydifícil", 
    "助教2019Emily12解說05真棒", 
    "2019R12課程05すごい", 
    "R程式2019的12期中考05とても変態")
)
```
然而即使忽略非數字文字，三個數字的組合誰是年月日依然受每個國家日期書寫習慣影響，所以有時候可能會有誤判的狀況  

### 4.6.1 正規表示式 Regular Expression  
一種廣義描述所要字串規律的表示法，分成兩部份:  

* target pattern: 指對取出字串的描述。如"108","98"是我們想取出的字串。我們可以說目標是，  
    + 「0-9的字元2-3個」: `[:digit:]{2,3}或[0-9]{2,3}`  
    
* target location description: 指target位置的情境描述。如"民國108年","民國98年"，我們可以說，  
    + target前面是「民國」後面是「年」: `(?<=民國)target_pattern(?=年)`  
    
* 合成regular expression (regex): `(?<=民國)[0-9]{2,3}(?=年)`  
```{r}
str_extract_all(
  c("民國108年12月5日","民國98年10月5日"),
  "(?<=民國)[0-9]{2,3}(?=年)"
) # 回傳list 

str_extract(
  c("民國108年12月5日","民國98年10月5日"),
  "(?<=民國)[0-9]{2,3}(?=年)"
) # 回傳vector 
```
<img src="C:/Users/USER/Desktop/R/RStudio Cheatsheets/regular_expressions.jpg" style="display:block; margin:auto; width:100%;">  

### 4.6.2 組合 alternate
用來製做一台吃角子老虎，它能夠包含你要的所有可能target出象。吃角子老虎由數條reel strip組成，每一條strip可以有以下幾種設計  

* __固定字元/組__: 單寫一個字組或字元，表示那個strip固定不動只有一個出象，例如: `2`表示只有"2"一個出象，`櫻桃`只有"櫻桃"一個出象
```{r}
heartSutra <- c("舍利子，色不異空，空不異色；色即是空，空即是色。")
str_view_all(heartSutra,"色") # 檢視
str_count(heartSutra,"色") # 計數
```
* __字「群」組合__ `(..|..|..)`: strip上的出象會出現一組字時用，如"AB|ab", 可以產生"AB"或"ab"兩種出象  
    + 字群組合規則若很單純前後沒有接其他描述則`( )`可不寫
```{r}
studentIds <- c("410873029","410773005","410772035","410562123")
# 取出學號中的入學屆為107或108
str_view_all(studentIds,"(107|108)") # 可不寫()
# 是否來自107或108學屆
str_detect(studentIds, "107|108")
```
* __字「元」組合__`[]`: strip上的出象「均」是一個字「元」時用，如`[af78]`可以產生"a","f","7","8"四種字元出象  
幾種常見的字元模版:
    + `[0-9](或[:digit:])`  
    + `[a-z](或[:lower:])`  
    + `[A-Z](或[:upper:])`  
    + `[0-9a-zA-Z](或[:alnum:])`  
```{r}
Ids <- c("A283743192","B829103720","A10920402","C291022384")
str_view_all(Ids, "[AC]")
str_detect(Ids, "[AC]") # 偵測 出現A、C
str_extract(Ids,"[A-Z]") # 取出 A-Z的字元
```

* 將設定好的reel strips依你要的順序排好就是你的regex slot machine
，它可以用來驗證字串裡頭是否出現來自你regex slot machine的某些組合  
<img src="C:/Users/USER/Documents/GitHub/yikahui/regex slot machine.png" style="display:block; margin:auto; width:20%;">  

```{r}
strip1 <- "[0-9]"
strip2 <- "(櫻桃|777|紅心)" # 字群組合strip因為等下放中間所以需使用()
strip3 <- "[A-Z]"
myRegexSlotMachine <- paste0(strip1,strip2,strip3)
print(myRegexSlotMachine)
claimA <- "我得到A檸檬99"
claimB <- "我的是7777Z"
claimC <- "我玩了兩次，一次是7蘋果H，另一次是5紅心J"
# 顯示吻合的出象
str_view(c(claimA,claimB,claimC),
         pattern=myRegexSlotMachine
         )
# 是否有吻合的出象
str_detect(c(claimA,claimB,claimC),
           pattern=myRegexSlotMachine
           )
```

* __以否定法定義的字「元」組合__`[^ ]`: `[^趙錢孫李]`不能有趙錢孫李任何一個  

範例  
```{r}
headline <- "資科系的謝陳官乃飛鳶書院三大名師，其中謝無雙的策略運算，陳大器的數理資科學，及官求敗的運算成本更是打通演算思維任督二脈的三大好課。書院目前有陳一、陳二、陳三四這三名學生。"
# 顯示所有符合規則的
str_view_all(headline, "謝陳官") # 固定字組
str_count(headline,"謝陳官")

str_view_all(headline, "[謝陳官]") # 有1個strip: 出象有3個可能字元 
str_count(headline, "[謝陳官]")

str_view_all(headline, "謝無雙|官求敗") # 有1個strip，出象有2個字組 
str_count(headline, "謝無雙|官求敗")

str_view_all(headline, "陳[^官]") # 固定字元＋有1個strip： 出象為排除官以外的字元
str_count(headline, "陳[^官]")
```
請使用`str_extract`函數粹取出每個地址的"xx號"包含"號"字  
```{r}
addresses <- c('臺中市后里區公館里尾社路385號',
               '新竹市東區科學園路125號1樓')
strip1 <- strip2 <- strip3 <- "[0-9]"
strip4 <- "號"
myRegexSlotMachine <- paste0(strip1,strip2,strip3,strip4)
print(myRegexSlotMachine)
str_extract(addresses,myRegexSlotMachine)
```
### 4.6.3 複製次數 Quantifiers  
`(..|..|...)`或`[...]`只是一條reel strip。有時我們同樣的belt想連放很多條，可以在`(..|..|...)`或`[...]`後面加:  

* `{n}`: 放n條belt，n是數字  
* `+`: 放1條以上的belt(多少不限)  
* `{n,m}`: 放n到m條belt，n及m都是數字  

將以下地址的號數取出(含"號"字)   
```{r}
addresses <- c('臺中市后里區公館里尾社路385號',
               '新竹市東區科學園路125號1樓',
               '新竹市北區竹光路99號',
               '金門縣金城鎮賢庵里山前33號',
               '臺中市南屯區工業區二十四路23號1樓')
myRegexSlotMachine <- "[0-9]+號"
print(myRegexSlotMachine)
str_view_all(addresses, myRegexSlotMachine)
str_extract(addresses, myRegexSlotMachine)
```
了解如何regex形式的描述你的target後，接下來我們進一步學習如何更準確描述target在整個字串的位置  

### 4.6.4 頭尾定位 Anchors  

* 在開頭: `^target_regex`  
* 在結尾: `target_regex$`  
```{r}
phrase <- c("唧唧復唧唧")
# 目標是前面的唧唧
target_regex <- "唧唧"
pattern <- glue::glue("^{target_regex}") 
print(pattern)
str_view(phrase, pattern) 
```
glue套件裡的glue函數會把字串中的`{物值名稱}`換成目前Environment裡該物件的值。在上面`{target_regex}`會被換成“唧唧”  
```{r}
# 目標是後面的唧唧
target_regex2 <- "唧唧"
pattern <- glue::glue("{target_regex2}$")
print(pattern)
str_view(phrase, pattern) 
```

### 4.6.5 前後鄰居描述 Look around  

* target後面是B:　`target_regex(?=B_regex)`，例如target_pattern後面是年  
* target前面是A: `(?<=A_regex)target_regex`，例如target_pattern前面是民國  
* target前有A後有B：`(?<=A_regex)target_regex(?=B_regex)`  

民國年月日存成date class:  
```{r}
twDate <- c("民國108年12月5日","民國98年10月5日")
# 準備regex: 
## 取出：「前有」民國，「後有」年的「數字」「們」
target_regex <- "[0-9]+"
A_regex <- "民國"
B_regex <- "年"
regex_pattern <- glue::glue("(?<={A_regex}){target_regex}(?={B_regex})")
print(regex_pattern)
## 也可以直接寫
regex_pattern <- "(?<=民國)[0-9]+(?=年)"
# 取出民國年，計算西元年
year <- str_extract(twDate, regex_pattern)
westernYear <- as.integer(year)+1911
# 替換民國xx年的xx成西元年數字
str_replace(twDate,
            regex_pattern,  # 要換掉的文字
            as.character(westernYear) # 要替換的內容
            ) -> twDate_reformat
print(twDate_reformat)
lubridate::ymd(twDate_reformat)
```
康熙元年是西元1662年，請將"康熙23年5月6日"轉成date class (假設月日已是西曆月日)  
```{r}
kangshiDate <- "康熙23年5月6日"
regexPattern <- "(?<=康熙)[:digit:]+(?=年)"
westernYear <- as.numeric(str_extract(kangshiDate,
                                      regexPattern)
                          )+1661
kangshiDate_reformat <- str_replace(kangshiDate,
                                    regexPattern,
                                    as.character(westernYear)
                                    )
lubridate::ymd(kangshiDate_reformat)
```
使用`str_extract`函數粹取出以下地址的"xx號"，不要取到「號」字只取出數字  
```{r}
print(addresses)
str_extract(addresses,
            "[:digit:]+(?=號)")
```
### 4.6.6 字元模版  

* `[:graph:]`: 包山包海，還包中文字元  
* `[\u4E00-\u9FFF]`: 代表所有中日韓文字字元  
```{r}
str_extract_all("我的名字8293叫17380小abce明",
                "[\u4E00-\u9FFF]+")
```
### 4.6.7 綜合練習  
學期初在輸入Github inclass-practice-repo網址時，它要長得像  
```
https://github.com/...../108-2-XX-inclass-practice
```
其中XX只可以是56或78，以下是課程資訊表單學生填答的可能形式，請寫下正確格式的regex，並用`str_detect`判斷哪幾個人沒有正確填寫:  
```{r}
c("https://github.com/student1/108-2-78-inclass-practice", 
  "github.com/student2 / 108-2-56-inclass-practice", 
  "https://github.com/student3/108-2-56-inclass-practice",
  "student4 / 108-2-56-inclass-practice",
  "student5"
  ) -> studentGithubURLs
str_detect(studentGithubURLs,
           "https://github.com/[:graph:]+/108-2-(56|78)-inclass-practice")
```
期中考檔案命名出現以下幾種寫法:  
```{r}
midtermFilename <- c("exam1-410773888.rmd",
                     "exam1410882888.Rmd",
                     "410682999第一次期中考.Rmd",
                     "期中考310573888.R")
# 請「只」以str_extract完成以下任務:  
## 1. 取出9位數的學號(4或3開頭的數字)  
student_id <- str_extract(midtermFilename, 
                          "[43][:digit:]{8}")
print(student_id)
## 2. 系號是學號的第5-6兩位數字, 如410773082的系號是73  
department <- str_extract(student_id, 
                          "[:digit:]{2}(?=[:digit:]{3}$)")
print(department)
## 3. 如果多了兩位99年入學但休學多年的學生(學號只有8位數49975013及49977012，系號是第4-5位數），他們的檔案名稱分別是“exam149975013.Rmd”,“499770121stExam.Rmd”,執行以下程序更新midterFilename:  
midtermFilename <- c(midtermFilename,"exam149975013.Rmd","499770121stExam.Rmd")
student_id <- str_extract(midtermFilename, 
                          "[43](99|105|106|107|108)[:digit:]{5}")
print(student_id)
department <- str_extract(student_id, 
                          "[:digit:]{2}(?=[:digit:]{3}$)")
print(department)
```
## 4.7 On factor class  
* 內定levels順序是根據電腦內字元排序（collating sequence）依辭典序列方式決定排序，很多時候沒有意義  
```{r}
char1 <- c("Wild","Apple","Donald","May","Avocada") 
factor1 <- factor(char1)
levels(factor1) #依據字首字母從A排到Z
char2 <- c("蔡英文","習近平","Donald Trump","蔡頭") 
factor2 <- factor(char2)
sort(str_sub(char2,1,1))
sort(str_sub(char2[c(1,4)],2,2))
levels(factor2)
```
* 查詢你的collating sequence設定：  
```{r}
Sys.getlocale("LC_COLLATE")
```
[由於不同電腦、不同作業系統的collating sequence不同，如果levels順序在你的分析是重要的，一定要在設定factor時自行設定好]  

***  
嚴重特殊傳染性肺炎  
```{r}
jsonlite::fromJSON("https://od.cdc.gov.tw/eic/Day_Confirmation_Age_County_Gender_19CoV.json") -> covid19
# 不可排序類別：性別、縣市、是否境外移入
covid19$`縣市` <- factor(covid19$`縣市`)
covid19$`性別` <- factor(covid19$`性別`)
covid19$`是否為境外移入` <- factor(covid19$`是否為境外移入`)
# 可排序類別資料：年齡層
covid19$`年齡層` <- factor(covid19$`年齡層`,ordered=TRUE)
levels(covid19$`縣市`)
levels(covid19$`性別`)
levels(covid19$`是否為境外移入`)
levels(covid19$`年齡層`)
```
### 4.7.1 levels重新排列  
重新再定義factor一次  
`factor(目前的factor向量, levels=自訂排序)`  

* levels放第二格時，`levels=`可省略  
* 目前的類別向量的可不可排序性質依然會保留，不用特意去設`ordered=T/F`  

使用函數時，若argument input的位置就是原help說明裡定義該argument位置時，「argument_name =」部份可以不寫。  

***  
手動輸入排法：由女男改男女  
```{r}
levels(covid19$`性別`)
covid19$`性別` <- factor(covid19$`性別`, c("男","女"))
```
***
依與levels相關的其他數據排列：  

* covid19$縣市的levels依其人口由大排到小。如“新北市”人口最多，它就要排levels的第一個，依此類推。  
演算思維：  
1. 下載台灣各縣市人口資料：  
```{r}
jsonlite::fromJSON("https://www.dropbox.com/s/jckqryeh5zeat5w/regionPopulation.json?dl=1") -> population
unlist(population) -> population
```
資料科學心法一：拿到新的資料先檢視「內容」、「class/type」  
```{r}
print(population)
class(population) #named integer vector
names(population) 
```
2. 留下levels中有的popluation元素  
```{r}
levels(covid19$`縣市`) # 是名稱字串向量
# 由於population元素值有names，可以用[名稱字串向量]取出所要的
levels(covid19$`縣市`) -> levelsInData
population[levelsInData] -> population
```
3. 將population由大排到小(`sort(x, decreasing=T)`可將`x` numeric vector由大排到小)  
```{r}
population <- sort(population, decreasing=T)
population
```
4. 排完後population第一個元素值最大，它的名稱即是人口最多的縣市，第二元素值次大，它名稱是人口第二多縣市，依此類推。我們要的是population排完後的元素名稱  
```{r}
newLevels <- names(population)
newLevels
```
5. 重設levels排序  
```{r}
covid19$`縣市` <- factor(covid19$`縣市`, levels=newLevels)
levels(covid19$`縣市`)
```
***  
* 將`covid19$縣市`依縣市目前個案數目由大排到小。  
```{r}
case <- table(covid19$`縣市`)
case <- sort(case, decreasing=T)
covid19$`縣市` <- factor(covid19$`縣市`, levels=names(case))
levels(covid19$`縣市`)
```
***  
年齡應該用年齡區間起始數字排序  
```{r}
levels(covid19$`年齡層`)
```
1. 取出levels中各年齡層的起始數字，存在startingAges
```{r}
level_names <- levels(covid19$`年齡層`)
startingAges <- stringr::str_extract(level_names,
                                     "^[0-9]+" # regex：開頭的一串數字
                                     )
```
2. 將startingAges變成named integer vector
```{r}
# 要numerical class排的才一定對
startingAges <- as.integer(startingAges)
names(startingAges) <- level_names
```
3. 將startingAges從小排到大
```{r}
sort(startingAges) -> startingAges
```
4. 重設levels排序
```{r}
covid19$`年齡層` <- factor(covid19$`年齡層`, 
                           names(startingAges)
                           )
levels(covid19$`年齡層`)
```
### 4.7.2 levels改名  
`levels(x) <- `  

在R裡，若你看到函數f說明在Usage同時寫上`f() <-`的用法時，它表示此函數除了一般用來產生結果以外，也可以用來設定結果  

* levels: 一般用來顯示類別  
* levels <- : 用來設定類別  
其他常用到設定用法的還有`names()`,`attr()`等等  
```{r}
factor1 <- factor(c("A","A","C","A","D","F","D","D"))
factor1
levels(factor1) <- c("優","佳","尚可","普")
factor1
```
也可改levels其中幾個利用元素取代概念
```{r}
levels(factor1)[[1]] <- "Excellent"
levels(factor1)[c(3,4)] <- c("C","D")
factor1
```
[由於factor內容的呈現是依循levels對照表走，所以levels內容一變，factor的內容呈現也變了]  

### 4.7.3 levels整併  
* 範例一：原本levels是台灣各縣市，你想改成北/中/南/東部四類  
由covid19$縣市建立一個**地區**變數，值為北部、中部、南部、東部，其中：  

* 北部："宜蘭縣、基隆市、台/臺北市、新北市、桃園市、新竹市、新竹縣"  
* 中部："苗栗縣、台/臺中市、彰化縣、南投縣、雲林縣"  
* 南部："嘉義市、嘉義縣、台/臺南縣、台/臺南市、高雄市、屏東縣、澎湖縣"  
* 東部："花蓮縣、台東縣"  
```{r}
covid19$`地區` <- covid19$`縣市`
levels(covid19$`地區`)
currentLevels <- levels(covid19$`地區`)
# 整併
north_regex <- "宜蘭縣|基隆市|[台臺]北市|新北市|桃園市|新竹市|新竹縣"
middle_regex <- "苗栗縣|[台臺]中市|彰化縣|南投縣|雲林縣"
south_regex <- "嘉義市|嘉義縣|[台臺]南[縣市]|高雄市|屏東縣|澎湖縣"
east_regex <- "花蓮縣|台東縣"
currentLevels <- str_replace(currentLevels, north_regex, "北部")
currentLevels <- str_replace(currentLevels, middle_regex, "中部")
currentLevels <- str_replace(currentLevels, south_regex, "南部")
newLevels <- str_replace(currentLevels, east_regex, "東部")
levels(covid19$`地區`) <- newLevels
levels(covid19$`地區`)
```
***  
* 範例二：將covid19$年齡層，由5歲間距成10歲間距，使改完後的levels為4 < 5-14 < 15-24 < …< 55-64 < 65+
```{r}
levels(covid19$`年齡層`)
# 創造10歲間距的所有可能
start <- seq(5, 55, by=10) # 由5到55，每個值差10的數值向量
end <- seq(14, 64, by=10)
middleLevels <- rep(
  paste0(start,"-",end), each=2 # 每個新間距要2個
) 
newLevels <- c("4", middleLevels, "65+", "65+")
levels(covid19$`年齡層`) <- newLevels
levels(covid19$`年齡層`) 
```
### 4.7.4 levels擴充  
`levels <-`右邊值的部份包含原本的外，還有想新增的類別  
```{r}
factor2 <- factor(c("好","好","普通","普通", "好"))
levels(factor2)
```
加一筆新資料"差"(之前沒有這類)  
```{r}
factor2[[6]] <- "差"
factor2 # 元素6變NA
```
先擴大levels，再加新資料
```{r}
factor2 <- factor(c("好","好","普通","普通", "好"))
levels(factor2) 
# 先擴大levels
levels(factor2) <- c(levels(factor2), "差")
levels(factor2)
factor2[[6]] <- "差"
factor2
```
factor無法用`c(...)`把兩個factor vector串接在一起：
```{r}
# non factor
char1 <- c("小明","小美")
char2 <- c("大雄","技安")
c(char1, char2)
# factor
factor1 <- factor(c("好", "壞", "壞"))
factor2 <- factor(c("壞", "好", "好"))
c(factor1, factor2)
```
因為`The output type is determined from the highest type of the components in the hierarchy NULL < raw < logical < integer`  
`< double < complex < character < list < expression. factor是integer type`所以會被當integer後才串接在一起。  

正確接法：  
```{r}
factor1[4:6] <- factor2
factor1
```
或使用套件forcats裡的`fct_c`函數：
```{r}
forcats::fct_c(factor1, factor2)
```
### 4.7.5 綜合練習
* 將covid19$性別的levels名稱男、女改Male、Female  
```{r}
levels(covid19$`性別`) <- c("Male", "Female")
```
* 以下資料為新北市垃圾車路線  
```{r}
jsonlite::fromJSON("https://data.ntpc.gov.tw/od/data/api/EDC3AD26-8AE7-4916-A00B-BC6048D19BF8?$format=json") -> garbageRoutes
```
(1) 在garbageRoutes新增route元素，其元素值為對應`garbageRoutes$linename`裡粹取出的"XXX路線"字眼，如原本"A11路線(一、四)下午"的linename, 它的route值為"A11路線 。(`garbageRoutes$route`為factor class)  
```{r}
levels(factor(garbageRoutes$linename))
route <- str_extract(garbageRoutes$linename,
                 "^[:graph:]+路線")
route <- factor(route)
garbageRoutes$route <- route 
levels(garbageRoutes$route)
```
(2) 請設定`garbageRoutes$route`的levels依其路線停靠總站數由小排到大陳列。
```{r}
stops <- names(
  sort(
    table(garbageRoutes$route)
  )
)
garbageRoutes$route <- factor(garbageRoutes$route, levels=stops)
```
(3) linename的"路線"字眼後面接的是營運時間，如"A11路線(一、四)下午"的linename, 它的營運時間為"(一、四)下午"。若沒寫時間的路線，它的營運時間為"全天"。請在garbageRoutes新增time元素，其元素值為對應linename所隱含的營運時間。(`garbageRoutes$time`為factor class， levels會有"(一、四)下午"，"下午"，"下午(1.4版)"，"晚上"，及"全天")
```{r}
garbageRoutes$time <- 
str_extract(
      garbageRoutes$linename,
      "(\\(一、四\\)下午|(?<!\\(一、四\\))下午(?!\\(1\\.4版\\))|下午\\(1\\.4版\\)|晚上)"
    )
allday <- is.na(garbageRoutes$time)
garbageRoutes$time[allday] <- "全天"
garbageRoutes$time <- factor(garbageRoutes$time)
levels(garbageRoutes$time)
```
(4) 將`garbageRoutes$time`的levels中的"下午(1.4版)"改成"下午"。
```{r}
levels(garbageRoutes$time)[[3]] <- "下午"
levels(garbageRoutes$time)
```
## 4.8 On list
### 4.8.1每個元素相同運算
```{r}
print(example)
```
我們有可能想要拿出其中屬於小新的資料：
```{r}
pick_小新 <- example$name == "小新"
data_selected <- list(name=example$name[pick_小新],
                      weight=example$weight[pick_小新],
                      height=example$height[pick_小新],
                      hobby=example$hobby[pick_小新],
                      residence=example$residence[pick_小新],
                      allowance=example$allowance[pick_小新],
                      bloodType=example$bloodType[pick_小新])
data_selected
```
`data_selected`的產生，相當於進行
```
example[[1]][pick_小新],
example[[2]][pick_小新],
example[[3]][pick_小新],
example[[4]][pick_小新],
example[[5]][pick_小新],
example[[6]][pick_小新],
example[[7]][pick_小新]
```
再存放在`list()`裡。也就是我們想要：  

* 對`example`底下的每個元素進行  
* `[pick_小新]`的動作  

purrr底下的`map()`允許我們  

* 使用`.x`來代表每個元素，即`[[1]], [[2]], ..., [[7]]`  

所以  

* 對每個元素進行`[pick_小新]`  
* 可以寫成`.x[pick_小新]`。  

由於`.x[pick_小新]`是個公式化的動作，在R，`~`代表要形成一個公式(formula)，所以

* 要寫成`~ .x[pick_小新]`

完整的`map()`用法為：
```
map(對象物件, ~對每個元素作的動作)
```
以一開始的例子為例：  

* 對`example`底下的每個元素進行  
* `.x[pick_小新]`的動作
```{r}
library(purrr)
map(example, ~.x[pick_小新]) -> data_selected 
data_selected
```
範例：舞蹈表演  
```{r}
jsonlite::fromJSON("https://cloud.culture.tw/frontsite/trans/SearchShowAction.do?method=doFindTypeJ&category=3", simplifyDataFrame = F) -> dance
# 第一個dance表演名稱
dance[[1]]$title
# 第二個dance表演名稱
dance[[2]]$title
```
若想得到所有表演的名稱，我們得：  

* 對 dance 每一個元素(`.x`表示)進行  
* `.x$title`的動作  
```{r}
map(dance, ~.x$title) -> list_titles
View(list_titles)
```
每個表演有時不止演出一場，每個表演的場次總數：  
```{r}
# 記載第一個表演的所有場次訊息
dance[[1]]$showInfo
str(dance[[1]]$showInfo)
# 計算第一個表演有幾個場次
length(dance[[1]]$showInfo)
# 計算第二個表演有幾個場次
length(dance[[2]]$showInfo)
```
* 對 dance 每個元素進行  
* `length(.x$showInfo)`的動作  
```{r}
map(dance,~length(.x$showInfo)) -> list_numberOfShows 
View(list_numberOfShows)
```
第5個表演有4個場次，想知道它們的日期時間：  
```{r}
str(dance[[5]]$showInfo)
# 這個表演第1個場次的訊息
dance[[5]]$showInfo[[1]]$time
# 這個表演第2個場次的訊息
dance[[5]]$showInfo[[2]]$time
```
* 對`dance[[5]]$showInfo`的每個元素(`.x`)表示  
* 進行`.x$time`動作  
```{r}
map(dance[[5]]$showInfo, ~ .x$time) -> list_showTimes_dance5
```
找出第8個表演的所有場次時間(time)和地點(location)：
```{r}
map(dance[[8]]$showInfo, ~ .x[c(1,2)]) -> list_showInfo_dance8
```
### 4.8.2 綜合練習
1. 新北市公車路線清單  
   請抓出每條路線的Id(路線代碼)、providerId(業者代碼)、providerName(業者中文名稱)、nameZh(中文名稱)。  
```{r}
jsonlite::fromJSON("https://data.ntpc.gov.tw/od/data/api/67BB3C2B-E7D1-43A7-B872-61B2F082E11B?$format=json", simplifyDataFrame = F) -> busRoutes
map(busRoutes, ~.x[c(1,2,3,4)]) -> busRoutes_info
```
2. 一般天氣預報-今明36小時天氣預報
```{r}
jsonlite::fromJSON("https://opendata.cwb.gov.tw/fileapi/v1/opendataapi/F-C0032-001?Authorization=rdec-key-123-45678-011121314&format=JSON") -> weather_next36hours
```
2.1 找出有氣象預報資訊的縣市名稱（locationName欄位）
```{r}
locationName <- weather_next36hours$cwbopendata$dataset$location$locationName
```
2.2 氣象局針對每個縣市提供了不同氣象因子在未來三個時段的預報。每個都市的氣象因子預報有那些，以第一個都市為例，它存在
```
weather_next36hours$cwbopendata$dataset$location$weatherElement[[1]]$elementName 
```
請取出每個縣市有提供的氣象預報因子名稱。（個別名稱的意思要去看欄位說明文件）
```{r}
map(weather_next36hours$cwbopendata$dataset$location$weatherElement,
    ~.x$elementName) -> elementName
elementName[[1]]
```
2.3 請抓出每縣市在第一個預告時段的  

* 預告開始時間
* 預告結束時間
* 這段時間的最高氣溫
```{r}
map(weather_next36hours$cwbopendata$dataset$location$weatherElement,
    ~.x$time[[2]]$startTime[[1]]) -> startTime_1
map(weather_next36hours$cwbopendata$dataset$location$weatherElement,
    ~.x$time[[2]]$endTime[[1]]) -> endTime_1
map(weather_next36hours$cwbopendata$dataset$location$weatherElement,
    ~.x$time[[2]]$parameter$parameterName[[1]]) -> highest_1
```















 